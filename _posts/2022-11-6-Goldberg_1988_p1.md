1. 问题的定义
   1. 网络：有向图，在任意一个点对上定义容量，不存在的边定义为0。
      1. 没有要求对称(symmetric)
      2. 定义的时候没有补边，只是补了一下不存在的边的容量定义
      3. 没有对有没有环作要求
   2. 流的定义
      1. 容量限制 反对称性 守恒性，和sleator一致
      2. 反对称性的好处
         1. 一组相反(a->b b->a)的边上不可能都有正流，简化了问题分析
         2. 简化了守恒性的表达（否则需要分别表示每个节点的出边和入边，让它们相等）
      3. 反对称性的理解
         1. 假设拿掉图里所有的负边，只留下正边（也就是非零边的一半，每一对有流量的边，只留下一个）
         2. 原本，每个节点的入边容量和为0，这些边的流量有正有负，现在拿掉了所有负流量边，则这些负流量边对应的出边是正流量边，且
            1. 原本的正流量入边的流量之和 等于 原本的负流量入边对应的正流量出边的流量之和
         3. 也就是说，在满足反对称性和守恒性时，拿掉负边后，就是一个入边流量等于出边流量的守恒网络。这也表明，从这种具有反对称性的解，恢复为一般形式的解，只需要拿走负边。
2. 算法：使用preflow求最大流问题
   1. 定义
      1. preflow: 一个满足容量限制和反对称性，但将守恒性弱化为非负性的流
         1. 除了s点外，每个节点的入流之和大于0
      2. flow excess: 流溢出$e(v)$，某个节点入流比出流大的部分
      3. 定义残留边 残留图
      4. 定义valid labeling（映射$d(v)$）
      5. v is active, 如果它不是起止节点，d(v)不是无穷，e(v)大于0
         1. 也就是一个有溢出，需要且能够（可达t，至少可达s）被考虑的点
   2. 思想：
      1. 考虑除了s和t点之外有溢出（excess）的节点，把溢出尽量往t点推，如果做不到，再往s点推；推干净以后，就得到了一个最大流。
         1. 如何推？ 存在朝向t的有残余容量的边，就可以往那边推
            1. 定义一条边的余量为$r_f(v,w) = c(v,w) - f(v,w)$
               1. 注意，如果$c(v,w)$为0，且$f(v,w)$是负的，余量也是正的。此时$f(w,v)$是正的，增加$f(v,w)$其实是减少网络上已经存在的流量。
            2. 可以推多少，由余量和溢出量共同决定$\sigma = min(e(v), r_f(v,w))$
            3. 定义残余边：余量**大于**0的边
            4. 定义残留图：$G_f = (V, E_f)$，边是残余边的集合。
            5. 如1所述，“推”其实包括两种情况，增大一个边上的流量但不超过容量，减少一个边上已经存在的容量但不得小于0
         2. 如何定义“往t点推”？ 即定义一个节点和s t之间的距离
            1. 定义 valid labeling $d$，一个从节点到非负整数和无穷大的函数，满足
               1. $d(s) = n, d(t) = 0$ 
               2. 对于任何一条残留边$(v,w)$，$d(v) \leq d(w) + 1$
            2. 有点像分层网络，不过是从终点出发的，是否也通过BFS得到？
            3. 原文到目前为止还没有考虑分层的情况
            4. 如果$d(v)$小于$n$，则是到t的路径长度的下界
               1. 对于无环图，假设从某点v有若干条到点t的路径，它们的长短不一，其中最短的一条长度为k，则$d(v)$不可能大于k，否则在最短的路径中，一定有一条边没办法满足$(v,w)$，$d(v) \leq d(w) + 1$
               2. 再说明$d(v)$可能小于$k$，对于最短路径，进一步假设这条路径上的每一个边$m,n$都满足$d(m) = d(n) + 1$，则此时$d(v)$就是到v的最短路径的长度。但考虑到$d(m)$可能小于$d(n)+1$，故$d(v)$可能小于最短路径的长度$k$。
                  1. 随便构造一个例子也可以说明
               3. 综上，$d(v)$是最短路径长度的下界，也就是路径长度的下界
            5. 如果$d(v)$大于等于$n$，则$d(v) - n$是到n的长度的下界。
               1. 问题：把所有节点赋为0，是否也是一种符合题意的解？
   3. 做法
      1. 先构建一个preflow：在每个从source发出的边上，流等于容量，其他地方是0
      2. 初始化label
         1. 简单的初始化方法：s点设为n，其它为0。s的出边已经被填满，此时s的出边都不在残留图(residual graph)里，因此s点和图的其他部分是断开的，此时把其他点的label都设置为0，没有问题。
            1. 要么两个节点都是0，要么是s的入边，此时是两个节点的label是$(0,n)$，$0 \leq n + 1$显然成立
         2. 更好的初始化方法（能避免大量的label操作）
            1. 设为$min(d_{G_f}(v,t),d_{G_f}(v,s) + n)$
            2. 用BFS搜一下
      3. 然后反复执行两种基本操作：push relabel
         1. push，将点的溢出量往前推
         2. relabel，将点的label设为可能的最大值
   4. 有效性的证明
      1. 引理：对于一个preflow，有着一个有效的labeling映射，则其中任何一个active节点，要么可以push，要么可以relabel。（最后不会出现有active节点但不能push的情况）
         1. 只要一个溢出的节点还有一个有残余容量的边和其他节点连接，根据push和relabel的定义，其中一定有一种操作可以执行，形式上看是显然的
         2. 暗含了这样的假设：active节点一定会至少和一个东西连在一起（考虑到有负边，应该可靠，不知怎么证）
      2. 引理：两种操作会维持labeling mapping $d$正确性
         1. 添加反边后，节点上的label之间的关系为$n -> n+1$，因为push操作只能push那些出发节点已经到达它容许的最大值的点，仍然有效。
         2. 正边要么仍然存在，要么直接没有掉。
         3. relabeling显然不会影响正确性
      3. 定义：augmenting path(增广路径),残差图中从起点到终点的一条路径
      4. 定理：直接引自Fulkerson:一个流(flow，not preflow)是最大流 等价于 没有别的增广路径
         1. 残差图不一定只能在preflow上定义，明显也能在flow上定义
         2. 因为这里定义了流的反对称性，并通过扩展容量的定义引出了residual edge的定义，所以可以直接使用增广路径这一定义，与Fulkerson中的叙述等价
      5. 引理:如果一个流是preflow，且上有valid labeling d，则t无法从d处得到
         1. 如果得证的话：
            1. flow也是preflow，所以如果一个flow，上面有valid labeling d，它就是一个最大流。且push label都能保持valid labeling，故连续变换后，只要能得到flow，就得到了最大流。
         2. 证法：把握$v(s)$为n即可，如果连得通，它不可能有这么大
      6. 定理：假设算法能够终止，且所有距离标签（也就是labeling）是有限的，就可以得到最大流。
         1. 狗补充定义和讨论
            1. distance labels：是否可理解为依据某节点与s和t点之间的距离给出的label（但在push relabel过程中不一定总是严格成立）。如果一个点不通过任何残留边通往s或t，则它有无穷的distance label
            2. 依据上面的定义，active vertex without infinity label总能进行一种操作就很显然了。
         2. 如果没有无限标签，且算法已经终止，则此时除s t外，图上不存在有溢出量的点，preflow变为一个flow，结合上一条引理里的讨论，就得到了最大流。
      7. 引理：一个preflow中，某个节点有溢出，则残留图中，能从它到达s
         1. 将某个v节点能到达的点集成为A，它的补集为B。假设A集合里没有s点。
         2. 任何一个从B到A的边，都不可能有正流量。
            1. 如果是正的，则它的反对称边是负的，容量最低是0，容量减流量是正的，则该边的终点也应该在A集里，推出矛盾。
         3. 因为是preflow，且A集不包括s点，所以A集里每个点的溢出量（其实也就是净的流入量，因为preflow里它总是大于0，故又称作excess，溢出）必然大于0。依据前面的结论，又有A集中溢出量的和小于等于0。综上，A集中各点溢出量的和为0，进而每个点的溢出量为0，进而v点的溢出量为0，推出矛盾。
         4. 据此定理，active点总是可达s点，一个active点的溢出总是有机会变成0，故算法可以结束；且这些点不可能有无穷的label的。
         5. **没必要讨论不active的点，因为它们不妨碍一个preflow变成flow ?**
      8. 综上，可能已经得证，原文跳过了这个引理之后的部分，感觉有点不连贯。
   5. 复杂度的证明
      1. 引理：任何节点的距离标签不会降低，每次relabeling都会增加它
      2.  引理：任何一个节点的标签小于2n-1
         1. 证明中只讨论了active点，没讨论不active的点，为何？一个不active的点是不是不会再变得active？
      3.  引理，总的relabel的次数最多$(2n-1)(n-2)$次
          1.  节点个数和标签上限乘一下就有了
      4.  引理，saturating push发生的次数有上限
          1.  saturating push：将一个残边搞没的push
          2.  一个残边被一次push搞没，到下一次又可以发生，期间某个节点的label至少增加了2（不可能减少）。一来一回，两个节点的label至少增加了4。考虑到两个节点的label的和分布于1到$4n-3$，故这两个点之间最多可能会发生$2n-1$次饱和push。整个算法过程中会发生2nm次饱和push。
          3.  遇到原图里存在着相对边的情况，是否不太靠谱。
      5.  引理：不饱和push的次数也有上限
          1.  把握中间量：所有活跃节点的label之和
          2.  一次不饱和push会导致上述中间量减少至少1（如果原本目标节点是inactive的，一来一回减少了1，如果原本目标节点是active的，减少了出发节点的label那么多）。一次饱和push会导致上述中间量增大至多$2n-1$（一个节点上能存在的最大的label值），ralabeling会导致增加最多$(2n-1)(n-2)$
          3.  考虑到$m \geq n-1$，总的不饱和次数的上限是$4n^2m$
      6.  定理：综上，各种操作都是有上限的，因此算法的运行时间是有上限的。
   6. 不需要具体的流，只需要最大流的值的情况
      1. 将active vertex的定义修改为$e(v) > 0$且$d(v) < n$
         1. 即只把溢出量往t上推，不往回朝s上推
3. 一种顺序的实现方式
   1. 所使用的特殊的数据结构
      1. 每个边存储三个元素：$c(v,w) c(w,v) f(v,w)$
         1. 在两个节点里存储这些边的引用，而且顺序固定
      2. 每个节点记录当前边，待push
      3. 全局维持一个active节点的表
   2. 做法
      1. 循环
         1. 选一个active点
         2. 尝试在current edge上push，若不能push
            1. 尝试切换current edge到表里下一个项，若已经是最后一个
               1. relabel，并将current edge设置为第一个
   3. 证明
      1. 有效性：relabel不会发生在不应该发生的时候，因此使用这种策略，最后总是能把该做的操作都做完
         1. relabel发生需要的条件，对于所有从某个点出发的边，要么$d(v) \leq d(w)$，要么$r_f(v,w)$等于0
            1. 第一个条件总是成立的，因为如果对于某个边来说，从它上一次作为current edge到现在，$d(v)$不变，$d(w)$只会增加；所以之前满足这个条件的边，现在也满足。
            2. 对于其他边，即当时$d(v) = d(w) + 1$，但余量为0的边（满足第一个条件的已经讨论过了，只说余量为0，两种情况重叠）。固然存在$d(w)$突然变大，然后推给v点的情况，但此时虽然余量不为0了，$d(w)$一定大于$d(v)$，满足了第一个条件。否则它仍然满足第二个条件。
      2. 复杂度：
         1. 每个节点扫列表的次数为$4n - 1$，分别来自于
            1. $2n - 1$ 次relabeling，同前，考虑到label最大是2n-1，每次增加1
            2. $2n - 1$ 次扫描，因为一定要从第一个扫到最后一个，relabling才会发生
            3. 1次扫描，最后一次relabling后，在扫描过程中会把自己的溢出量都推光
         2. 扫描节点的过程的复杂度为 $\mathcal{O}( (4n - 1) * n * \Delta_i)$，其中$Delta_i$是每个节点的边数。如果认为平均边数远小于m，可以看作一个常数，则这部分的复杂度接近$\mathcal{O}(mn)$
         3. 在整个过程中，push操作需要另算，根据前面的推导，发生的push操作的复杂度也是$\mathcal{O}(n^2m)$
         4. 综上，整个过程的复杂度是$\mathcal{O}(n^2m)$
   4. discharge方法
      1. discharge操作：维持一个active节点的队列，先进先出，重复直到队列空
         1. 从前面取一个节点，反复进行push/relabel，直到它溢出变成0，或label增加，并把这个过程里变得active的节点放到队伍末尾
         2. 如果这个节点本身还有$e(v) > 0$，把它也一并放到末尾
      2. 这种算法的有效性可以保证，因为
         1. 对于取出来的那个东西，最后一定有一种操作让它的循环结束，一定完成了一次label或者push
            1. 回忆，对于每个active节点（有有限的label，但已经证明了不会有无限的），一定有一种操作是可以做的，所以要么能把自己的溢出推给下一个点（且推的次数也是有限的），如果都不能推，就可以relabel，relabel过程中label一定会上升。
            2. 每取出来一个东西，一定能做一次操作。
         2. 总的label或push次数是有上限的
   5. 通过调整discharge循环打断的条件来进一步减少复杂度
      1. 定义 pass，类似BFS里的一轮
      2. 引理 pass数最多$4n^2$
         1. 定义一个量标所有活跃节点的label的最大值，一个pass里，
            1. 如果它变大，肯定有一个节点（跟着它）一起变大
            2. 如果它不变，肯定有一个节点增大
               1. 考虑一种情况，一个label为2的节点，指向4个节点，label分别为1，1，1，7，且均active，它把自己的溢出值推给三个1，1，1节点后退出
               2. 上面两条确保变大和不变的次数最多是$2n^2$，因为再多，节点label的和就会超过上限
            3. 它可能变小，且最小变小1
         2. 考虑到算法执行开始和结束，上述量标都为0，最差的情况（仅考虑上面描述的几个限制条件，不考虑更细节的条件，比如显然不太可能有那么大的label）就是，该量标每次随着某个节点的label增加1而增加1，最后一个一个减回去。不可能再执行更多次数了。
      3. 引理，非饱和push最多$4n^3$
         1. 对于每个点，只会发生一次非饱和的push。（完了以后它的溢出变成0，退出队列）
         2. 饱和push的复杂度是$nm$

4. 问题
   1. 环的问题，在最大流问题中，有没有一种方法将有环图转换为无环图？考虑到环流总是会让流变小
   2. 引理4.3的证明有一个小问题，不变的时候为什么一定变大

5. 狗言狗语
   1. d(s)为n，n为节点数，其实就是为了应付一个一个连起来的特殊情况
   2. 感性理解，一个点会一边连着t，一边连着s，s这边的临近点label大于n，t这边的小于n。往t能推的都推了，那边的都断了，这时更新label就会突然变得很大。
      1. 以n为界划分label，体现了优先往t推，不行的话往s推的思想。