1. 问题定义
    1. 问题的引入
       1. 马戏团运送大象老虎猴子马，每个车有容量，大象过重不能一次两只，老虎放一起打架，同性猴子打架  **如何转换成网络流问题？**
    2. 定义网络（Network） $\mathscr{N} = (V, E, C, s, t)$
       1. C是从节点对到实数的映射，任意节点对都可以映射到一个大于等于0的数。
          1. 如果一对节点映射到0，则它们之间没有边。
    3. 定义流
       1. 流小于容量
       2. 流的反对称性：$F(u,v) = -F(v,u)$
          1. 该定义里，其实没有对F为正或负下定义
          2. 实际上给f提供了上限和下限，如果一个图中只有边(u,v)而没有(v,u)，则同时限制了$f(u,v)$大于等于0，因为 $-f(u,v) = f(v,u) \leq 0$
       3. 流的守恒性 (conservation)
           1. 仅s与t的流出量不为0
              1. 易证，这两个值总是互为相反数
           2. 其它节点的流出量和流入量都为0
    4. 其定义中的新颖之处在于
        1. 流和容量定义在所有点对上（传统定义下，只定义在存在着的边上）
        2. 流可以为负（传统定义下是非负的）
        3. **每一个传统定义下的问题，都可以等价的转化为该定义下的问题**
           1. （狗言狗语，可能扯淡） 传统问题 -> 此定义
              1. 将存在的边的容量保留，不存在的设为0
           2. 此定义解 -> 传统问题
              1. 将流中值大于0的保留
    5. 该定义的优势在于，在涉及到流的守恒性时，相关记法可以简化
        1. 例如，所有从s点和t点流出的流大小相反（在一般的流上显然是不成立的）

2. Dinit 算法
   1. 存储用数据结构的需求
      1. 遍历从某个节点出发的所有边所需的时间是固定的
      2. 为每个节点创建一个链表，里边存储所有从它出发的边的信息，包括容量，费用和另一端的目标节点
   2. Dinit算法解决对称图上的最大流问题
      1. 对称图：边和反边同属于网络
      2. 构造对称图：如果反边不存在，加一条容量是的0反边
      3. （不必讨论其它作者定义的“后向流 或 有效流 （backward / useful flow）”）
   3. 思想：将最大流问题简化为一系列的阻塞流（blocking flow）问题
   4. 相关定义
      1. block flow
         1. 定义：从s到t的每条通路上，都至少有一条属于这个流的饱和边
            1. 饱和边，流量等于容量的边
            2. 注意分辨$(u,v) \isin E$和容量$C(u,v)$有定义
         2. 一个无环图，在填补反向边后，不再是无环图
            1. 但填补容量为0的反向边，不会增加容量大于0的环
            2. 但后面关于blocking flow的定义似乎也没限制必须在无环图上
      2. 到该文发表为止，所有的快速网络流算法都使用了所谓的 "capacity alteration"技术
         1. 其实就是用流量更新容量
            1. 注意，0容量会被更新为正容量
         2. 相关引理
            1. $\mathscr{N}'$由$\mathscr{N}$经过$F$转换得到，则$F'$是$\mathscr{N}'$中的blocking flow 等同于 $F' + F$是$\mathscr{N}$中的blocking flow
               1. 描述
                  1. 没有关系原本的$F$是否blocking，只要留下的图里有个blocking flow，则和它相加，就可以得到原本的图中的blocking flow
                  2. alter若干次以后的余留的图里，只要找到一个blocking flow，再和之前每次alter时候遇到的blocking flow加起来，就能得到一个原图里的blocking flow。相当于把这个引理使用多次。
               2. 证明，把握$C'-F'=C-(F'+F)$即可
                  1. 在$C'$里，每个path上都有一个饱和边，即$C'-F'$为0，由上式$C-(F'+F)$也为0，因此在C里，这些path上的对应边也饱和了
                     1. 左边总是大于等于0，因此右边也总是大于等于0，满足流量小于容量的限制
                  2. $F',F$都满足守恒性和反对称性，加起来也满足这两个条件。至此，三个条件都满足。
      3. 分层网络
         1. 是一个无环图以及节点的一种划分。
            1. 其中的节点，边和容量是原图的一个子集。注意原图是对称的，因此很可能是有环的，分层网络包括它的一个无环子集。
               1. 节点：出现在各个层的节点的并
               2. 边：能连接相邻层的正容量边
                  1. 可能不是之前构建节点的时候的用的正容量边，一层里可能有多个节点能通过不同的正容量边连接到下一层的某个节点，按照定义，这些边都会出现在这个子集里。
               3. 映射函数C，把不属于新的边集合的设置为0
            2. 节点的划分方法
               1. 0层，出发点
               2. i+1层中的节点，是所有i层中的节点可以经过一条正容量的边达到的节点，除去已经出现在0到i层中的节点
               3. 最后一层，或者空，或者包含终点
            3. 如果最后一层是空的，设置一个标志位
         2. 根据上面的定义，能想到构建该网络的算法
         3. 性质
            1. 一层一层走，该网络表示了所有长度为$num\_of\_layer - 1$的路径
            2. 该算法能作用于有环图，会导致存在相邻的两层，其中第一层的某个点和下一层的任何一个点都没有有效通路
               1. 把环“拉”开一点，即把入环的节点变成两三个相邻的节点，构成局部的分岔路，此时也是成立的。
            3. 它一定是无环的，因为只包含一层里的节点到下一层的节点的边，且显然一个节点不会同时出现在两层里
   5. 相关算法
      1. 在一个无环图中找到一个Blocking flow
         1. 做法
            1. 深度优先，搜一条路径
               1. 由于确保了是一个无环图，因此不需要在图上标记点是否已经被访问过
               2. 如果成功搜到了一条路径，则这个路径上不会有边被标记，只有在一个边一定无法通向终点时，才被标记
                  1. 无法通向终点：没有从它出发的未被标记的正边
                     1. 被标记了的边，都是无法通向终点的，因此下一个点必须经过未被标记的边，否则一定无法通向终点
                     2. 0边一定无法通向终点
                  2. 在一次搜索阻塞流的过程中，这些标记总是存在的，不会被移除
            2. 在这个路径上找一个capacity最小的，以此为依据创建一个flow（不一定是blocking flow，但一定使某个边饱和），并更新alternated network
            3. 反复以上步骤，直到找不到新的path
            4. 找到总的阻塞流
               1. 因为前面所述的引理，可以把每步找到的流加起来
         2. 有效性的证明
            1. 迭代终止后，任何一条路径会经过一个0边
               1. 根据定义：最终得到的图上，任意一条s到t的路径，都会经过标记了的边，或者是0边
                  1. 否则就不是最终的图，就可以再增广一次
               2. 使用数学归纳法证明，任何一条路径，如果通过了一个被标记的边，则它上面也一定有一个0边
                  1. 使用归纳法证明，对于第一个被标记的边，因为此前没有标记过任何边，因此从它发出的边一定都有0容量
                  2. 标记下一条边时，如果从它发出的边有被标记的边，则顺着往前走一定会有一个0边
               3. 由于任何一个路径一定经过了被标记的边或零边（根据迭代终止的定义），故任何一条路径都经过了0边
            2. 从而可知，迭代终止后的图上，0流是一个阻塞流。多以使用引理$C'-F'=C-(F'+F)$，从最后的饱和流开始，每加上上一次找到的那条路径形成的流，就得到了寻找上一条路经的网络中的一个阻塞流，一直到最开始的网络。
               1. 最开始的网络的阻塞流是每次找到的路径的和。
         3. 复杂度的推导
            1. 每找到一条路径，都会让网络中的一条边的流量归0，因此主循环最多可以迭代m（边的个数）次。
            2. 深度优先搜索的复杂度为$O(mn)$ （**理解可能有误**，从后文来看，认为寻找一次阻塞流的复杂度整个是$O(mn)$，每排除掉一条边最多查n个点？）
               1. 设想一种情况：
                  1. 将所有节点依次标号为1，2，3，4，5
                  2. 将每个节点连接到序号大于它的所有节点
                  3. 除了1-2 2-3这样的边之外，其它边容量都设置为0
                  4. 每个节点存储出边的顺序，恰好使1-2 2-3这样的边排在最后一个
                  5. 节点非常多
                  - 此时找一条边的时间复杂度接近$mn$ (是$nm/2$) 
             1. 狗言狗语，似乎不是很容易构造一个主循环迭代次数和深度优先的复杂度都到达上限的例子 
      2. Dinit算法
         1. 算法步骤
            1. 找一个分层图（一个对称图肯定是有环的），依照图里的边，容量，使用上述算法找一个blocking flow
            2. 更新图
            3. 重建分层图，迭代，直到分层图摸不到t点（也就是没有正边组成的路径）
         2. 证明：寻找阻塞流的算法的最多次数是有限的，最多为n-1
            1. 每次迭代中，第一步找到的分层图的层数一定比前一次大。
               1. 若得证，则
                  1. 如果某一次迭代中，找到的网络已经有n层了，则这时节点依次连接变得很长，此时只要找到一个阻塞流，减掉它后，下一次就摸不到t点了。故找到n层就意味着迭代马上结束，下一次就找不到分层图了。
                  2. 主循坏开始时，可构造出的分层图可能的层数为2,3,...,n，故构造分层图的算法最多会执行n次（包括最后一次找不到），寻找阻塞流的算法执行n-1次
               2. 证明
                  1. 先证明，如果一个网络的分层网络有$k+1$层，则在**被阻塞流alter后的网络**中的**从s到t的正容量路径长度**至少为k（k+1个点）
                     1. 如果有一条边连接了分层网络中的两个节点，从所在层序号小的节点出发，到达所在层序号大的节点，且中间跨过了一层，则它不在分层网络中，因此求得的阻塞流和它没有关系，因此它在原本网络里的值和在alter后的网络里的值是一样的。
                        1. 因此，不可能存在一条边，在于alter后的网络里有正容量，而在原本地网络里容量为0。alter前后容量是不变的。
                     2. 如果有一条路径长度小于k，它穿过小于$k+1$个点。把小于$k+1$个点分摊到$k+1$层里，然后用k个边将它们连接，则一定有一条边
                        1. 方向：从序号小的层到大的层
                        2. 距离：跨过了至少一个层
                        - 这样的边不应该存在。在构建分层网络的过程中，已经建好了一些层，只要残留的节点和已有的层有正边连接，一定马上出现在下一层里，因此从序号小的节点出发的正边不可能跨层。
                          - 没有出现在分层网络中的正边，要么连接同一层里的两个节点，要么从一层向后连到之前的层里。
                  2. 再证明在**被阻塞流alter后的网络**中的**从s到t的正容量路径长度**不可能还是k
                     1. 如果有一条路径长度为k，则它一定遵循，第一个点在（分层网络中的）第0层，第二个点在第1层，第k个点在最后一层的模式，否则会出现前面讨论过的，从序号小的层到序号大的层且跨过了多个层的边，这是不可能的
                        1. 狗言狗语：设每条边首位节点所在的层序号之差为$\Delta{d_i}$，则k个这样的差（对应k个边）的和为k，如果其中任何一个不为1，则一定有一个大于1。
                     2. 因此，这条路径上的边都在分层网络$\mathcal{N}^*$中，这条路径也在分层网络中。它会被阻塞流阻塞，alter后的网络里，这条路径上一定有一条边的容量变成0，因此它不可能是一条正容量边。
                  3. 综上，在**被阻塞流alter后的网络**中的**从s到t的正容量路径长度**必然大于k
         3. 因此，总的时间复杂度是$O(mn^2)$
         4. 证明找到的流是最大流
            1. 首先，所有找到的流的和是一个阻塞流。用前面的引理易证
            2. 其次，一个阻塞流是一个最大流
               1. 相关定义
                  1. 割，包括s点的节点的子集
                  2. 割的容量，从割到割的补集的边的容量的和
               2. 证明：流小于割的容量
                  1. 在本文采用的流的定义体系下，很好证
                  2. 同时证明了流的大小（s点出发的流量）等于**任意**一个割中，被割的边上的流之和
               3. 证明，在对称网络里，可以找到一个割，这个割的容量等于流
                  1. 将所有从s可通过未被流F饱和的边达到的节点集合作为割，对于任何一个从割到其补的点对$(u,v)$
                     1. 如果不是网络的一部分，上面一定没有流
                     2. 如果是网络的一部分，一定被阻塞流饱和，否则v点会在割里
                  2. 因此，在任何情况下，对于从割到其补的点对$(u,v)$，上面的流等于容量。进而，对于对称网络上的阻塞流，流的大小等于割的容量。
               4. 因为任何一个流，小于等于任何一个割，所以如果找到一个流和割相等的情况，就同时找到了最大流和最小割，得证。
   6. 狗言狗语
      1. 如果有一个图分出去的孤边，可以直接丢掉，最后需要考虑的边，都至少存在于一条s到t的路径中

2. 问题，为什么在对称图上Dinit算法的有效性这么好证，区别在哪？